# CKA 2025 실전 시험 패턴

## 🎯 2025년 실제 출제 패턴 기반 문제집

**사용법:**
1. **KillerCoda Kubernetes Playground** 접속: https://killercoda.com/playgrounds/scenario/kubernetes
2. 각 문제의 **환경 설정** 명령어를 실행하여 문제 상황 생성
3. **문제**를 읽고 해결 시도
4. **솔루션**을 참고하여 검증

---

## 📋 실제 시험 출제 패턴 (가중치별)

### 🔥 고빈도 출제 영역 (70% 이상)

#### 1. HPA 고급 설정 (가중치: 8%)

**문제:** `auto-scale` 네임스페이스에 `apache-server`라는 이름의 HPA를 생성하세요.

**요구사항:**
- CPU 사용률 50% 목표
- 최소 1개, 최대 4개 Pod
- 스케일 다운 안정화 시간 30초

**솔루션:**
```bash
# 환경 설정
kubectl create namespace auto-scale
kubectl create deployment apache-server --image=nginx:1.21 -n auto-scale
kubectl patch deployment apache-server -n auto-scale -p '{"spec":{"template":{"spec":{"containers":[{"name":"nginx","resources":{"requests":{"cpu":"100m","memory":"128Mi"}}}]}}}}'

# HPA 생성
cat <<EOF | kubectl apply -f -
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: apache-server
  namespace: auto-scale
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: apache-server
  minReplicas: 1
  maxReplicas: 4
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 30
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 50
EOF
```

---

#### 2. Deployment & NodePort 구성 (가중치: 10%)

**문제:** `spline-reticulator` 네임스페이스의 기존 deployment `front-end`를 재구성하여 nginx 컨테이너의 80/tcp 포트를 노출하세요.

**요구사항:**
- 컨테이너 포트 80/tcp 노출
- `front-end-svc`라는 이름의 새 서비스 생성
- NodePort를 통해 개별 Pod 노출

**솔루션:**
```bash
# 환경 설정
kubectl create namespace spline-reticulator
kubectl create deployment front-end --image=nginx:1.21 -n spline-reticulator

# Deployment 편집하여 containerPort 추가
kubectl patch deployment front-end -n spline-reticulator -p '{"spec":{"template":{"spec":{"containers":[{"name":"nginx","ports":[{"containerPort":80,"protocol":"TCP"}]}]}}}}'

# 서비스 생성
kubectl expose deployment front-end --name=front-end-svc --port=80 --target-port=80 -n spline-reticulator

# NodePort로 변경
kubectl patch service front-end-svc -n spline-reticulator -p '{"spec": {"type": "NodePort"}}'
```

---

#### 3. Sidecar 컨테이너 추가 (가중치: 8%)

**문제:** 기존 deployment `synergy-leverager`를 업데이트하여 `sidecar`라는 이름의 co-located 컨테이너를 추가하세요.

**요구사항:**
- Sidecar 이미지: `busybox:stable`
- 실행 명령: `/bin/sh -c "tail -n+1 -f /var/log/synergy-leverager.log"`
- `/var/log`에 마운트된 볼륨을 통해 로그 파일 공유

**솔루션:**
```bash
# 기존 deployment 삭제 후 sidecar가 포함된 새 deployment 생성
kubectl delete deployment synergy-leverager --ignore-not-found

cat <<EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: synergy-leverager
  labels:
    app: synergy-leverager
spec:
  replicas: 1
  selector:
    matchLabels:
      app: synergy-leverager
  template:
    metadata:
      labels:
        app: synergy-leverager
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
        command: 
        - sh
        - -c
        - |
          while true; do
            echo "\$(date): Application logging" >> /var/log/synergy-leverager.log
            sleep 5
          done &
          nginx -g 'daemon off;'
        volumeMounts:
        - name: data
          mountPath: /var/log
      - name: sidecar
        image: busybox:stable
        command: 
        - /bin/sh
        - -c
        - |
          while [ ! -f /var/log/synergy-leverager.log ]; do
            sleep 1
          done
          tail -n+1 -f /var/log/synergy-leverager.log
        volumeMounts:
        - name: data
          mountPath: /var/log
      volumes:
      - name: data
        emptyDir: {}
EOF
```

---

#### 4. CNI 설치 및 구성 (가중치: 10%)

**문제:** Native Network Policy 지원이 필요한 CNI를 설치하고 설정하세요.

**선택 옵션:**
- Flannel v0.26.1 (Network Policy 미지원)
- Calico v3.28.2 (Network Policy 지원)

**솔루션:**
```bash
# Network Policy 지원이 필요하므로 Calico 선택
kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.2/manifests/tigera-operator.yaml

# 설치 확인
kubectl get pods -n calico-system
kubectl get pods -n tigera-operator

# Network Policy 테스트
kubectl run test-pod1 --image=nginx:1.21 --labels="app=test1"
kubectl run test-pod2 --image=nginx:1.21 --labels="app=test2"

# 기본 연결 테스트
kubectl exec test-pod1 -- ping -c 2 $(kubectl get pod test-pod2 -o jsonpath='{.status.podIP}')

# Network Policy 생성 및 테스트
cat <<EOF | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: test-netpol
spec:
  podSelector:
    matchLabels:
      app: test2
  policyTypes:
  - Ingress
  ingress: []
EOF

# 차단된 연결 테스트
kubectl exec test-pod1 -- ping -c 2 $(kubectl get pod test-pod2 -o jsonpath='{.status.podIP}') || echo "Traffic blocked (expected)"
```

---

#### 5. ArgoCD Helm 설치 (가중치: 7%)

**문제:** 클러스터에 ArgoCD를 설치하세요.

**요구사항:**
- 공식 Argo CD Helm repository를 `argo` 이름으로 추가
- ArgoCD Helm Chart 버전 7.7.3의 템플릿을 `argocd` 네임스페이스용으로 생성
- `~/argo-helm.yaml`에 저장
- CRD 설치 비활성화

**솔루션:**
```bash
# Helm repository 추가
helm repo add argo https://argoproj.github.io/argo-helm
helm repo update

# 템플릿 생성 (CRD 설치 비활성화)
helm template argocd argo/argo-cd --version 7.7.3 -n argocd \
  --set crds.install=false > ~/argo-helm.yaml

# 생성된 템플릿 확인
ls -la ~/argo-helm.yaml
grep -c "^kind:" ~/argo-helm.yaml
grep -i "CustomResourceDefinition" ~/argo-helm.yaml || echo "No CRDs found (expected)"

# 적용
kubectl create namespace argocd
kubectl apply -f ~/argo-helm.yaml
```

---

### 🔧 중빈도 출제 영역 (30-70%)

#### 6. PriorityClass 구성 (가중치: 7%)

**문제:** 사용자 워크로드용 `high-priority`라는 이름의 새 PriorityClass를 생성하세요.

**요구사항:**
- 기존 사용자 정의 우선순위 클래스 값보다 1 작은 값
- `priority` 네임스페이스의 `busybox-logger` deployment에 적용

**솔루션:**
```bash
# 환경 설정
kubectl create namespace priority
kubectl create priorityclass existing-priority --value=1000 --description="Existing user priority class"
kubectl create deployment busybox-logger --image=busybox:1.35 --namespace=priority --replicas=2

# 새 PriorityClass 생성
kubectl create priorityclass high-priority --value=999 --description="High priority class for critical workloads"

# Deployment에 우선순위 클래스 적용
kubectl patch deployment busybox-logger -n priority -p '{"spec":{"template":{"spec":{"priorityClassName":"high-priority"}}}}'

# 확인
kubectl get pods -n priority -o custom-columns=NAME:.metadata.name,PRIORITY:.spec.priorityClassName,STATUS:.status.phase
```

---

#### 7. StorageClass 기본 설정 (가중치: 8%)

**문제:** `local-path`라는 이름의 StorageClass를 생성하고 기본 StorageClass로 설정하세요.

**요구사항:**
- Provisioner: `rancher.io/local-path`
- Volume Binding Mode: `WaitForFirstConsumer`
- 기본 StorageClass로 설정

**솔루션:**
```bash
# 기존 기본 StorageClass 제거
kubectl patch storageclass standard -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"false"}}}' || true

# 새 StorageClass 생성
cat <<EOF | kubectl apply -f -
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-path
  annotations:
    storageclass.kubernetes.io/is-default-class: "true"
provisioner: rancher.io/local-path
volumeBindingMode: WaitForFirstConsumer
reclaimPolicy: Delete
EOF

# 확인
kubectl get storageclass
kubectl describe storageclass local-path
```

---

#### 8. Gateway API 마이그레이션 (가중치: 12%)

**문제:** 기존 웹 애플리케이션을 Ingress에서 Gateway API로 마이그레이션하세요.

**요구사항:**
- HTTPS 접근 유지
- Gateway 이름: `web-gateway`
- 호스트명: `gateway.web.k8s.local`
- HTTPRoute 이름: `web-route`

**솔루션:**
```bash
# Gateway API CRD 설치
kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.1.0/standard-install.yaml

# 테스트 애플리케이션 및 서비스 생성
kubectl create deployment web-app --image=nginx:1.21 --replicas=1
kubectl expose deployment web-app --name=web-service --port=80

# TLS 인증서 생성
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout /tmp/tls.key -out /tmp/tls.crt \
  -subj "/CN=gateway.web.k8s.local"
kubectl create secret tls web-tls --cert=/tmp/tls.crt --key=/tmp/tls.key

# GatewayClass 생성
cat <<EOF | kubectl apply -f -
apiVersion: gateway.networking.k8s.io/v1
kind: GatewayClass
metadata:
  name: nginx
spec:
  controllerName: "nginx.org/gateway-controller"
EOF

# Gateway 생성
cat <<EOF | kubectl apply -f -
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
  name: web-gateway
spec:
  gatewayClassName: nginx
  listeners:
  - name: https
    protocol: HTTPS
    port: 443
    hostname: gateway.web.k8s.local
    tls:
      mode: Terminate
      certificateRefs:
      - kind: Secret
        name: web-tls
EOF

# HTTPRoute 생성
cat <<EOF | kubectl apply -f -
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: web-route
spec:
  parentRefs:
  - name: web-gateway
  hostnames:
  - "gateway.web.k8s.local"
  rules:
  - matches:
    - path:
        type: PathPrefix
        value: /
    backendRefs:
    - name: web-service
      port: 80
EOF
```

---

### 📊 시험 대비 체크리스트

#### ✅ 필수 암기 사항

1. **명령어 패턴**
   - `kubectl create` vs `kubectl apply`
   - `kubectl patch` 사용법
   - `kubectl expose` 옵션들

2. **YAML 구조**
   - HPA behavior 설정
   - NetworkPolicy 규칙
   - SecurityContext 옵션들

3. **문제 해결 순서**
   - 환경 설정 → 리소스 생성 → 확인 → 테스트

#### 🎯 시간 관리 전략

- **고가중치 문제 우선** (8% 이상)
- **명령형 명령어 활용** (빠른 생성)
- **YAML 템플릿 준비** (복잡한 리소스용)
- **검증 단계 필수** (kubectl get, describe)

#### 🚨 주의사항

1. **네임스페이스 확인** - 문제에서 지정한 네임스페이스 사용
2. **리소스 이름 정확히** - 문제에서 요구한 정확한 이름 사용
3. **포트 번호 주의** - containerPort vs port vs targetPort
4. **라벨 셀렉터 일치** - deployment와 service 간 라벨 일치

---

**🎉 2025 실전 시험 패턴 학습이 완료되었습니다!**
**실제 CKA 시험에서 자신 있게 문제를 해결할 수 있을 것입니다! 🚀**